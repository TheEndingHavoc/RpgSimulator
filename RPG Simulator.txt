local success, Rayfield = pcall(function()
    return loadstring(game:HttpGet('https://raw.githubusercontent.com/SiriusSoftwareLtd/Rayfield/main/source.lua'))()
end)

if not success or not Rayfield then
    warn("Failed to load Rayfield library: " .. tostring(Rayfield))
    return
end

-- Services
local VirtualInputManager = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Workspace = game:GetService("Workspace")

-- Player setup
local player = Players.LocalPlayer
local currentHRP = nil -- Will track current HumanoidRootPart

-- Create the window with configuration saving
local Window = Rayfield:CreateWindow({
    Name = "RPG Simulator Pro",
    LoadingTitle = "RPG Simulator Pro",
    LoadingSubtitle = "Respawn-Proof Auto Farm",
    ConfigurationSaving = {
        Enabled = true,
        FileName = "RPGSim_Configs"
    },
    KeySystem = false
})

-- Add tabs
local AutoSkillsTab = Window:CreateTab("Auto Skills", nil)
local AutoFarmTab = Window:CreateTab("Auto Farm", nil)
local AutoRaidTab = Window:CreateTab("Auto Raid", nil)
local AutoSettingsTab = Window:CreateTab("Settings", nil)

-- Shared variables
local isAutoSkillsEnabled = false
local selectedKeys = {Q = true, E = true, R = true}
local keySequence = {"Q", "E", "R"}
local currentKeyIndex = 1

-- Auto Click variables
local isAutoClickEnabled = false
local clickDelay = 0.1

-- Auto Farm variables
local isAutoFarmEnabled = false
local useSkillsWhileFarming = true
local farmDelay = 0.5
local currentTarget = nil
local mobTypes = {}
local selectedMobType = nil
local farmingThread = nil

-- Auto Raid variables
local raidOptions = {
    "Pirate Captain", "Obsidian Lair", "Deep Water Den", "Shadow Palace", 
    "Sun Warrior Temple F2", "Laboratory 1", "Crystal Caverns", "Rogue Hideout", 
    "Nest of the Colossal", "Tartarus", "Doctor V's Labyrinth", "Hive", 
    "Realm of Shadows", "The Rune King", "Mines", "Frost Dragon", 
    "Dungeon Endless", "Emperor of Time", "Frost Dragon's Rematch"
}
local selectedRaid = nil
local isHardcoreRaid = false
local isAutoRaidEnabled = false
local raidThread = nil
local currentRaidTarget = nil

-- Settings variables
local configsFolder = "RPGSim_Configs"
local autoExecute = false
local autoLoadConfig = false
local selectedConfig = nil
local configsList = {}
local currentSettings = {}

-- Permanent noclip function
local function setNoClip(enabled)
    if not currentHRP or not currentHRP.Parent then return end
    for _, part in ipairs(currentHRP.Parent:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = not enabled
        end
    end
end

-- Character management
local function trackCharacter(newCharacter)
    -- Wait for HumanoidRootPart to exist
    local hrp = newCharacter:WaitForChild("HumanoidRootPart")
    currentHRP = hrp
    
    -- Set up death detection
    local humanoid = newCharacter:WaitForChild("Humanoid")
    humanoid.Died:Connect(function()
        if isAutoFarmEnabled then
            -- Wait for respawn and restart farming
            player.CharacterAdded:Wait()
            task.wait(3) -- Respawning cooldown
            if isAutoFarmEnabled then
                startFarming()
            end
        end
        if isAutoRaidEnabled then
            player.CharacterAdded:Wait()
            task.wait(3)
            if isAutoRaidEnabled then
                startRaid()
            end
        end
    end)
    
    -- Re-enable farming if it was active
    if isAutoFarmEnabled then
        setNoClip(true)
        startFarming()
    end
    if isAutoRaidEnabled then
        setNoClip(true)
        startRaid()
    end
end

-- Initialize character tracking
if player.Character then
    trackCharacter(player.Character)
end
player.CharacterAdded:Connect(trackCharacter)

-- Mob detection function
local function getMobTypes()
    local mobsFolder = workspace:FindFirstChild("Mobs")
    if not mobsFolder then return {} end
    
    local types = {}
    for _, mob in ipairs(mobsFolder:GetChildren()) do
        if mob:FindFirstChild("HumanoidRootPart") and mob:FindFirstChildOfClass("Humanoid") and mob.Humanoid.Health > 0 then
            if not table.find(types, mob.Name) then
                table.insert(types, mob.Name)
            end
        end
    end
    return types
end

-- Key press simulation
local function simulateKeyPress(key)
    local keyCodes = {
        Q = Enum.KeyCode.Q,
        E = Enum.KeyCode.E,
        R = Enum.KeyCode.R
    }
    
    if keyCodes[key] then
        VirtualInputManager:SendKeyEvent(true, keyCodes[key], false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, keyCodes[key], false, game)
    end
end

-- Mouse click simulation
local function simulateMouseClick()
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
    task.wait(0.05)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
end

-- Find mob of selected type
local function findMob()
    if not currentHRP or not currentHRP.Parent then return nil end
    if not selectedMobType then return nil end
    
    local mobsFolder = workspace:FindFirstChild("Mobs")
    if not mobsFolder then return nil end
    
    -- If current target still valid, keep it
    if currentTarget and currentTarget.Parent and currentTarget:FindFirstChild("Humanoid") and currentTarget.Humanoid.Health > 0 then
        return currentTarget
    end
    
    -- Find closest mob of selected type
    local closestMob = nil
    local closestDistance = math.huge
    
    for _, mob in ipairs(mobsFolder:GetChildren()) do
        if mob.Name == selectedMobType and mob:FindFirstChild("HumanoidRootPart") and mob:FindFirstChildOfClass("Humanoid") and mob.Humanoid.Health > 0 then
            local distance = (mob.HumanoidRootPart.Position - currentHRP.Position).Magnitude
            if distance < closestDistance then
                closestMob = mob
                closestDistance = distance
            end
        end
    end
    
    return closestMob
end

-- Precise teleport function
local function teleportToTarget(target)
    if not currentHRP or not currentHRP.Parent then return end
    
    -- Exact position teleport with velocity reset
    local targetPos = target.HumanoidRootPart.Position
    currentHRP.CFrame = CFrame.new(targetPos)
    currentHRP.Velocity = Vector3.new(0, 0, 0)
    currentHRP.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    
    -- Force position update
    RunService.Heartbeat:Wait()
end

-- Main farming function
local function farmLoop()
    while isAutoFarmEnabled do
        -- Wait for valid HRP
        while not currentHRP or not currentHRP.Parent do
            task.wait(1)
        end
        
        -- Find and attack target
        local mob = findMob()
        if mob then
            currentTarget = mob
            
            -- Aggressive teleport
            teleportToTarget(mob)
            
            -- Maintain noclip
            setNoClip(true)
            
            -- Attack sequence
            simulateMouseClick()
            if useSkillsWhileFarming then
                for _, key in ipairs(keySequence) do
                    if selectedKeys[key] then
                        simulateKeyPress(key)
                    end
                end
            end
        end
        
        task.wait(farmDelay)
    end
end

-- Start/stop farming functions
local function startFarming()
    if farmingThread then
        coroutine.close(farmingThread)
    end
    
    isAutoFarmEnabled = true
    setNoClip(true)
    farmingThread = coroutine.create(farmLoop)
    coroutine.resume(farmingThread)
    
    Rayfield:Notify({
        Title = "Auto Farm",
        Content = "Enabled! Will survive respawns automatically.",
        Duration = 3
    })
end

local function stopFarming()
    isAutoFarmEnabled = false
    if farmingThread then
        coroutine.close(farmingThread)
        farmingThread = nil
    end
    setNoClip(false)
    currentTarget = nil
end

-- Auto Raid functions
local function getNil(name, class)
    for _, v in pairs(getnilinstances()) do
        if v.ClassName == class and v.Name == name then return v end
    end
end

local function teleportToRaid()
    if not selectedRaid then return end
    
    local args = {
        [1] = "Raid",
        [2] = selectedRaid,
        [3] = isHardcoreRaid
    }
    
    local raidEvent = getNil("raidEvent", "RemoteEvent") or 
                     game:GetService("ReplicatedStorage"):FindFirstChild("raidEvent") or
                     game:GetService("ReplicatedStorage").Events:FindFirstChild("raidEvent")
    
    if raidEvent then
        raidEvent:FireServer(unpack(args))
        Rayfield:Notify({
            Title = "Raid Teleport",
            Content = "Teleporting to "..selectedRaid..(isHardcoreRaid and " (Hardcore)" or ""),
            Duration = 3
        })
    end
end

local function activateAllClickDetectors()
    for _, detector in ipairs(workspace:GetDescendants()) do
        if detector:IsA("ClickDetector") then
            fireclickdetector(detector)
        end
    end
end

local function findClosestRaidMob()
    if not currentHRP or not currentHRP.Parent then return nil end
    
    local closestMob = nil
    local closestDistance = math.huge
    
    local mobsFolder = workspace:FindFirstChild("Mobs")
    if mobsFolder then
        for _, mob in ipairs(mobsFolder:GetChildren()) do
            if mob:FindFirstChild("HumanoidRootPart") and mob:FindFirstChildOfClass("Humanoid") and mob.Humanoid.Health > 0 then
                local distance = (mob.HumanoidRootPart.Position - currentHRP.Position).Magnitude
                if distance < closestDistance then
                    closestMob = mob
                    closestDistance = distance
                end
            end
        end
    end
    
    return closestMob
end

local function raidLoop()
    while isAutoRaidEnabled do
        -- Wait for valid HRP
        while not currentHRP or not currentHRP.Parent do
            task.wait(0.5)
        end
        
        -- Activate all click detectors
        activateAllClickDetectors()
        
        -- Find closest mob
        local mob = findClosestRaidMob()
        if mob then
            currentRaidTarget = mob
            
            -- Continuous attack loop with teleportation every 0.5 seconds
            local lastTeleport = 0
            while isAutoRaidEnabled and mob.Parent and mob:FindFirstChildOfClass("Humanoid") and mob.Humanoid.Health > 0 do
                local now = tick()
                
                -- Teleport every 0.5 seconds
                if now - lastTeleport >= 0.5 then
                    if not teleportToTarget(mob) then
                        break -- If teleport fails, find new target
                    end
                    setNoClip(true)
                    lastTeleport = now
                end
                
                -- Built-in Auto Click and Auto Skills for Auto Raid
                autoClick()
                keySpam()
                
                task.wait(0.1)
            end
            
            -- Small cooldown after killing a mob
            task.wait(0.5)
        else
            -- If no mobs found, wait a bit before checking again
            task.wait(1)
        end
    end
end

local function startRaid()
    if raidThread then
        coroutine.close(raidThread)
    end
    
    isAutoRaidEnabled = true
    setNoClip(true)
    raidThread = coroutine.create(raidLoop)
    coroutine.resume(raidThread)
    
    Rayfield:Notify({
        Title = "Auto Raid",
        Content = "Enabled! Will survive respawns automatically.",
        Duration = 3
    })
end

local function stopRaid()
    isAutoRaidEnabled = false
    if raidThread then
        coroutine.close(raidThread)
        raidThread = nil
    end
    setNoClip(false)
    currentRaidTarget = nil
end

-- Auto Skills function
local function keySpam()
    local currentKey = keySequence[currentKeyIndex]
    if selectedKeys[currentKey] then
        simulateKeyPress(currentKey)
    end
    
    currentKeyIndex = currentKeyIndex % #keySequence + 1
    task.wait(0.1)
end

-- Auto Click function
local function autoClick()
    simulateMouseClick()
    task.wait(clickDelay)
end

-- Connections
local keyConnection, clickConnection

local function toggleKeySpam(enabled)
    isAutoSkillsEnabled = enabled
    if enabled then
        keyConnection = RunService.Heartbeat:Connect(keySpam)
    elseif keyConnection then
        keyConnection:Disconnect()
        keyConnection = nil
    end
end

local function toggleAutoClick(enabled)
    isAutoClickEnabled = enabled
    if enabled then
        clickConnection = RunService.Heartbeat:Connect(autoClick)
    elseif clickConnection then
        clickConnection:Disconnect()
        clickConnection = nil
    end
    Rayfield:Notify({
        Title = "Auto Click",
        Content = enabled and "Enabled (Press F)" or "Disabled",
        Duration = 3
    })
end

local function toggleAutoFarm(enabled)
    if enabled then
        startFarming()
    else
        stopFarming()
    end
end

local function toggleAutoRaid(enabled)
    if enabled then
        startRaid()
    else
        stopRaid()
    end
end

-- Configuration System
local function saveCurrentSettings()
    currentSettings = {
        AutoSkills = {
            Enabled = isAutoSkillsEnabled,
            SelectedKeys = selectedKeys,
            KeySequence = keySequence
        },
        AutoClick = {
            Enabled = isAutoClickEnabled,
            Delay = clickDelay
        },
        AutoFarm = {
            Enabled = isAutoFarmEnabled,
            UseSkills = useSkillsWhileFarming,
            Delay = farmDelay,
            SelectedMob = selectedMobType
        },
        AutoRaid = {
            Enabled = isAutoRaidEnabled,
            SelectedRaid = selectedRaid,
            Hardcore = isHardcoreRaid
        },
        Settings = {
            AutoExecute = autoExecute,
            AutoLoadConfig = autoLoadConfig,
            SelectedConfig = selectedConfig
        }
    }
end

local function loadSettings(settings)
    -- Auto Skills
    isAutoSkillsEnabled = settings.AutoSkills.Enabled or false
    selectedKeys = settings.AutoSkills.SelectedKeys or {Q = true, E = true, R = true}
    keySequence = settings.AutoSkills.KeySequence or {"Q", "E", "R"}
    toggleKeySpam(isAutoSkillsEnabled)
    
    -- Auto Click
    isAutoClickEnabled = settings.AutoClick.Enabled or false
    clickDelay = settings.AutoClick.Delay or 0.1
    toggleAutoClick(isAutoClickEnabled)
    
    -- Auto Farm
    isAutoFarmEnabled = settings.AutoFarm.Enabled or false
    useSkillsWhileFarming = settings.AutoFarm.UseSkills or true
    farmDelay = settings.AutoFarm.Delay or 0.5
    selectedMobType = settings.AutoFarm.SelectedMob
    toggleAutoFarm(isAutoFarmEnabled)
    
    -- Auto Raid
    isAutoRaidEnabled = settings.AutoRaid.Enabled or false
    selectedRaid = settings.AutoRaid.SelectedRaid
    isHardcoreRaid = settings.AutoRaid.Hardcore or false
    toggleAutoRaid(isAutoRaidEnabled)
    
    -- Settings
    autoExecute = settings.Settings.AutoExecute or false
    autoLoadConfig = settings.Settings.AutoLoadConfig or false
    selectedConfig = settings.Settings.SelectedConfig
    
    Rayfield:Notify({
        Title = "Config Loaded",
        Content = "Settings applied successfully!",
        Duration = 3
    })
end

local function getConfigsList()
    if not isfolder(configsFolder) then
        makefolder(configsFolder)
        return {}
    end
    
    local files = listfiles(configsFolder)
    local configs = {}
    
    for _, file in ipairs(files) do
        local name = file:match(".+\\(.+).json")
        if name then
            table.insert(configs, name)
        end
    end
    
    return configs
end

local function saveConfig(name)
    if not name or name == "" then 
        Rayfield:Notify({
            Title = "Error",
            Content = "Config name cannot be empty!",
            Duration = 3
        })
        return 
    end
    
    -- Prevent invalid file names
    name = name:gsub("[^%w _-]", "")
    
    saveCurrentSettings()
    
    local success, err = pcall(function()
        if not isfolder(configsFolder) then
            makefolder(configsFolder)
        end
        
        local path = configsFolder.."\\"..name..".json"
        writefile(path, HttpService:JSONEncode(currentSettings))
    end)
    
    if success then
        Rayfield:Notify({
            Title = "Config Saved",
            Content = "Configuration '"..name.."' saved successfully!",
            Duration = 3
        })
        configsList = getConfigsList()
        -- Update dropdown
        configDropdown:Set(configsList)
    else
        Rayfield:Notify({
            Title = "Error",
            Content = "Failed to save config: "..tostring(err),
            Duration = 5
        })
    end
end

local function loadConfig(name)
    if not name or name == "" then return end
    
    local success, err = pcall(function()
        local path = configsFolder.."\\"..name..".json"
        local data = readfile(path)
        return HttpService:JSONDecode(data)
    end)
    
    if success then
        loadSettings(err)
        selectedConfig = name
    else
        Rayfield:Notify({
            Title = "Error",
            Content = "Failed to load config: "..tostring(err),
            Duration = 5
        })
    end
end

local function deleteConfig(name)
    if not name or name == "" then return end
    
    local success, err = pcall(function()
        local path = configsFolder.."\\"..name..".json"
        delfile(path)
    end)
    
    if success then
        Rayfield:Notify({
            Title = "Config Deleted",
            Content = "Configuration '"..name.."' removed!",
            Duration = 3
        })
        configsList = getConfigsList()
        if selectedConfig == name then
            selectedConfig = nil
        end
        -- Update dropdown
        configDropdown:Set(configsList)
    else
        Rayfield:Notify({
            Title = "Error",
            Content = "Failed to delete config: "..tostring(err),
            Duration = 5
        })
    end
end

-- Auto-execute on teleport
local function setupAutoExecute()
    if autoExecute then
        saveCurrentSettings()
        local settingsString = HttpService:JSONEncode(currentSettings)
        
        TeleportService:SetTeleportSetting("RPGSimSettings", settingsString)
        
        player.OnTeleport:Connect(function(teleportState)
            if teleportState == Enum.TeleportState.Started then
                queue_on_teleport([[
                    wait(1)
                    loadstring(game:HttpGet("https://raw.githubusercontent.com/TheEndingHavoc/RpgSimulator/refs/heads/main/RPG%20Simulator.txt"))()
                ]])
            end
        end)
    end
end

-- Initialize config system
configsList = getConfigsList()

-- UI Elements
-- Auto Skills Tab
AutoSkillsTab:CreateToggle({
    Name = "Auto Skills",
    Info = "Spams Q, E, R in sequence",
    CurrentValue = false,
    Flag = "AutoSkillsToggle",
    Callback = toggleKeySpam
})

AutoSkillsTab:CreateDropdown({
    Name = "Active Skills",
    Options = {"Q", "E", "R"},
    CurrentOption = {"Q", "E", "R"},
    MultipleOptions = true,
    Flag = "KeyFilter",
    Callback = function(values)
        selectedKeys = {Q = false, E = false, R = false}
        for _, key in ipairs(values) do
            selectedKeys[key] = true
        end
    end
})

AutoSkillsTab:CreateToggle({
    Name = "Auto Click",
    Info = "Toggle with F key",
    CurrentValue = false,
    Flag = "AutoClickToggle",
    Callback = toggleAutoClick
})

AutoSkillsTab:CreateSlider({
    Name = "Click Speed",
    Info = "Adjust auto click speed",
    Range = {0.05, 1},
    Increment = 0.01,
    CurrentValue = 0.1,
    Flag = "ClickSpeedSlider",
    Callback = function(value)
        clickDelay = value
    end
})

-- Auto Farm Tab
local mobDropdown
task.spawn(function()
    -- Wait for mobs to load
    repeat
        mobTypes = getMobTypes()
        task.wait(1)
    until #mobTypes > 0

    mobDropdown = AutoFarmTab:CreateDropdown({
        Name = "Mob Type",
        Info = "Select which mobs to farm",
        Options = mobTypes,
        CurrentOption = nil,
        Flag = "MobTypeDropdown",
        Callback = function(value)
            selectedMobType = value
            currentTarget = nil
        end
    })

    -- Refresh mob types periodically
    RunService.Heartbeat:Connect(function()
        local newMobTypes = getMobTypes()
        if #newMobTypes > 0 and #newMobTypes ~= #mobTypes then
            mobTypes = newMobTypes
            mobDropdown:Set(newMobTypes)
        end
    end)
end)

AutoFarmTab:CreateToggle({
    Name = "Enable Auto Farm",
    Info = "Survives respawns with perfect positioning",
    CurrentValue = false,
    Flag = "AutoFarmToggle",
    Callback = toggleAutoFarm
})

AutoFarmTab:CreateToggle({
    Name = "Use Skills While Farming",
    CurrentValue = true,
    Flag = "UseSkills",
    Callback = function(value)
        useSkillsWhileFarming = value
    end
})

AutoFarmTab:CreateSlider({
    Name = "Action Delay",
    Info = "Delay between farming actions",
    Range = {0.1, 2},
    Increment = 0.1,
    CurrentValue = 0.5,
    Flag = "FarmDelay",
    Callback = function(value)
        farmDelay = value
    end
})

-- Auto Raid Tab
AutoRaidTab:CreateDropdown({
    Name = "Raid Selection",
    Info = "Choose which raid to join",
    Options = raidOptions,
    CurrentOption = nil,
    Flag = "RaidSelection",
    Callback = function(value)
        selectedRaid = value
    end
})

AutoRaidTab:CreateToggle({
    Name = "Hardcore Mode",
    CurrentValue = false,
    Flag = "HardcoreToggle",
    Callback = function(value)
        isHardcoreRaid = value
    end
})

AutoRaidTab:CreateButton({
    Name = "Teleport to Raid",
    Info = "Join the selected raid",
    Callback = teleportToRaid
})

AutoRaidTab:CreateToggle({
    Name = "Auto Raid",
    Info = "Teleports every 0.5s & uses skills",
    CurrentValue = false,
    Flag = "AutoRaidToggle",
    Callback = toggleAutoRaid
})

-- Settings Tab
AutoSettingsTab:CreateToggle({
    Name = "Auto Execute on Teleport",
    Info = "Automatically re-runs script when changing servers",
    CurrentValue = false,
    Flag = "AutoExecuteToggle",
    Callback = function(value)
        autoExecute = value
        if value then
            setupAutoExecute()
            Rayfield:Notify({
                Title = "Auto Execute",
                Content = "Script will auto-restart when teleporting",
                Duration = 3
            })
        end
    end
})

local configDropdown = AutoSettingsTab:CreateDropdown({
    Name = "Configurations",
    Info = "Select a configuration",
    Options = configsList,
    CurrentOption = nil,
    Flag = "ConfigSelector",
    Callback = function(value)
        selectedConfig = value
    end
})

AutoSettingsTab:CreateInput({
    Name = "Create New Config",
    Info = "Enter config name to save current settings",
    PlaceholderText = "Config name",
    Flag = "CreateConfigInput",
    Callback = function(value)
        if value and value ~= "" then
            saveConfig(value)
        else
            Rayfield:Notify({
                Title = "Error",
                Content = "Config name cannot be empty!",
                Duration = 3
            })
        end
    end
})

AutoSettingsTab:CreateButton({
    Name = "Overwrite Config",
    Info = "Update selected config with current settings",
    Callback = function()
        if selectedConfig then
            saveConfig(selectedConfig)
        else
            Rayfield:Notify({
                Title = "Error",
                Content = "No config selected!",
                Duration = 3
            })
        end
    end
})

AutoSettingsTab:CreateButton({
    Name = "Load Config",
    Info = "Apply selected configuration",
    Callback = function()
        if selectedConfig then
            loadConfig(selectedConfig)
        else
            Rayfield:Notify({
                Title = "Error",
                Content = "No config selected!",
                Duration = 3
            })
        end
    end
})

AutoSettingsTab:CreateButton({
    Name = "Delete Config",
    Info = "Remove selected configuration",
    Callback = function()
        if selectedConfig then
            deleteConfig(selectedConfig)
        else
            Rayfield:Notify({
                Title = "Error",
                Content = "No config selected!",
                Duration = 3
            })
        end
    end
})

AutoSettingsTab:CreateToggle({
    Name = "Auto Load Config",
    Info = "Automatically load selected config on start",
    CurrentValue = false,
    Flag = "AutoLoadToggle",
    Callback = function(value)
        autoLoadConfig = value
        if value and selectedConfig then
            Rayfield:Notify({
                Title = "Auto Load",
                Content = "Will auto-load '"..selectedConfig.."' next time",
                Duration = 3
            })
        end
    end
})

-- Hotkey
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == Enum.KeyCode.F then
        toggleAutoClick(not isAutoClickEnabled)
    end
end)

-- Auto-load config if enabled
if autoLoadConfig and selectedConfig then
    task.wait(1) -- Wait for UI to initialize
    loadConfig(selectedConfig)
end

-- Initial notification
Rayfield:Notify({
    Title = "RPG Simulator Pro",
    Content = "Script loaded with Rayfield UI!",
    Duration = 5
})

-- Load Rayfield configuration
Rayfield:LoadConfiguration()
